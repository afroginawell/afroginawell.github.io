(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{364:function(t,e,v){"use strict";v.r(e);var _=v(4),a=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"数据库chp3-1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据库chp3-1"}},[t._v("#")]),t._v(" 数据库Chp3-1")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),e("p",[t._v("本章为数据库测试题")])]),t._v(" "),e("p",[t._v("[TOC]")]),t._v(" "),e("h2",{attrs:{id:"题单"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#题单"}},[t._v("#")]),t._v(" 题单")]),t._v(" "),e("p",[t._v("1.A->AC is a（B）")]),t._v(" "),e("p",[t._v("A.\ttrivial FD;\tB.\tnontrivial FD;")]),t._v(" "),e("p",[t._v("C.\tcompletely nontrivial FD;\tD.\tcompletely trivial FD")]),t._v(" "),e("details",{staticClass:"custom-block details"},[e("summary",[t._v("【解析】")]),t._v(" "),e("p",[t._v("FD（function dependency）：函数依赖。简而言之，某个属性集决定另一个属性集时，称另一属性集依赖于该属性集。需要强调的是，函数依赖是关系所表达信息本身具有的语义特性，而不能由属性构成关系的方式来决定，也不能由关系的当前内容所决定。")]),t._v(" "),e("p",[t._v("A. trivial FD（平凡函数依赖）：当关系中属性集Y是属性集合X的子集时（Y$\\subseteq$X），存在函数依赖X$\\rightarrow$Y，即一组属性函数决定它的所有子集，这种函数依赖称为平凡函数依赖。")]),t._v(" "),e("p",[t._v("B. nontrivial FD（非平凡函数依赖）：当关系中属性集合Y不是属性集合X的子集时，存在函数依赖X$\\rightarrow$Y，则称这种函数依赖为非平凡函数依赖。")]),t._v(" "),e("p",[t._v("C. completely nontrivial FD（部分函数依赖）：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。")]),t._v(" "),e("p",[t._v("D. completely trivial FD（完全函数依赖）：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。")]),t._v(" "),e("p",[t._v("AC不是A的子集，选项A错误，这里并没有涉及到关系R，所以选择B")])]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("2.FD:{A→B,AB→E,BC→D}, find the closure of A。（C）")]),t._v(" "),e("p",[t._v("A.\tABCD;\tB.\tAB;\tC.\tABE;\tD.ABCDE;")]),t._v(" "),e("details",{staticClass:"custom-block details"},[e("summary",[t._v("【解析】")]),t._v(" "),e("p",[t._v("题目中FD是函数依赖的意思，find the closure of A可以理解为“找到A的闭包”。闭包：设F为属性集U上的一组函数依赖，X、Y∈U，(X+)={A|X|→A能由F根据Armstrong公理导出}，(X+)称为属性集X关于函数依赖集F的闭包。简而言之，闭包就是由一个属性直接或间接推导出的所有属性的集合，例如： f={a->b,b->c,a->d,e->f} ，由a可直接得到b和d，间接得到c，则a的闭包就是{a,b,c,d}。")]),t._v(" "),e("p",[t._v("A→B，说明A可以推导出B；AB→E，A可以推导出B，而AB又可以推导出E，说明A可以间接推导出E；BC→D，其中只有B可以从A推导出，无法说明C和D可以从A推导出；而A可以推导出其本身，所有A的闭包是{A,B,E}，选C。")]),t._v(" "),e("p",[t._v("【注释】"),e("a",{attrs:{href:"https://baike.baidu.com/item/Armstrong%E5%85%AC%E7%90%86/1187858?fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[t._v("Armstrong公理"),e("OutboundLink")],1),t._v("：从已知的一些函数依赖，可以推导出另外一些函数依赖，这就需要一系列推理规则。函数依赖的推理规则最早出现在1974年W.W.Armstrong 的论文里，这些规则常被称作“Armstrong 公理”。")])]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("3.Which of the following FD's is likely to be the minimal basis?（D）")]),t._v(" "),e("p",[t._v("A.\t{AB→AC,C→A};\tB.\t{AB→C,B→A};")]),t._v(" "),e("p",[t._v("C.\t{AB→C,B→C};\tD.{AB→C,C→A};")]),t._v(" "),e("details",{staticClass:"custom-block details"},[e("summary",[t._v("【解析】")]),t._v(" "),e("p",[t._v("题目的意思“以下哪个函数依赖可能是最小基？”")]),t._v(" "),e("p",[t._v("minimal basis(最小基)：最小基是一个函数依赖集合，满足以下三个条件：1）函数依赖的右侧是单个属性；2）没有一个函数依赖可以被移除；3）函数依赖的左侧没有一个属性可以被移除。")]),t._v(" "),e("p",[t._v("A.{AB→AC,C→A}不符合第一个条件")]),t._v(" "),e("p",[t._v("B.{AB→C,B→A}不符合第三个条件，B是可以单独推导出C的")]),t._v(" "),e("p",[t._v("C.{AB→C,B→C}不符合第三个条件，AB→C中A是多余的")]),t._v(" "),e("p",[t._v("D.{AB→C,C→A}符合三个条件")])]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("4.Since A→BC,B→D, yield A→D, the rules used in the derivation are（AC）。")]),t._v(" "),e("p",[t._v("A.\tthe spiltting/combining rule;\tB.\tthe combing rule;")]),t._v(" "),e("p",[t._v("C.\tthe transitive rule;\tD.\tnone of all above;")]),t._v(" "),e("details",{staticClass:"custom-block details"},[e("summary",[t._v("【解析】")]),t._v(" "),e("p",[t._v("题目可以理解为“从A→BC,B→D推导出A→D中使用了哪些规则？”")]),t._v(" "),e("p",[t._v("推导过程：从A→BC推导出A→B（分解规则the spiltting rule），从A→B,B→D推导出A→D（传递规则the transitive rule）")]),t._v(" "),e("p",[t._v("所以选A和C，the combining rule是联合规则（如果 X → Y 并且 X → Z 那么 X → YZ）")])]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("5.For the relation schema R(A,B,C) and FD's{B→A,A→B}, please list all the superkeys of R.（AB）")]),t._v(" "),e("p",[t._v("A.\tBC;\tB.\tABC;\tC.\tB;\tD.\tA;")]),t._v(" "),e("details",{staticClass:"custom-block details"},[e("summary",[t._v("【解析】")]),t._v(" "),e("p",[t._v("题目可以理解为“关系模式R(A,B,C)中存在关系依赖FD{B→A,A→B}，请找出关系模式R中的所有超键。”")]),t._v(" "),e("p",[t._v("superkey(超键)：在关系中能唯一标识元组的属性集称为关系模式的超键")]),t._v(" "),e("p",[t._v("FD's{B→A,A→B}可以看出来A和B可以互相标识，C可以标识C自身，所以BC或ABC都可以是超键。概念中的“唯一”与这个其实不矛盾，在这个情况下BC和ABC是可以划等号的，那么还是唯一，只是表示形式不同而已。")])]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("6.A→B holds, indicates the following statements are true.（ABD）")]),t._v(" "),e("p",[t._v("A.\tTwo tuples t1 and t2 agree on the attributes A, they also agree on the attributes B.")]),t._v(" "),e("p",[t._v("B.\tTwo tuples t1 and t2 do not agree on the attributes A, they may agree on the attributes B.")]),t._v(" "),e("p",[t._v("C.\tTwo tuples t1 and t2 agree on the attributes A, they do not agree on the attributes B.")]),t._v(" "),e("p",[t._v("D.\tTwo tuples t1 and t2 do not agree on the attributes A, they may not agree on the attributes B.")]),t._v(" "),e("details",{staticClass:"custom-block details"},[e("summary",[t._v("【解析】")]),t._v(" "),e("p",[t._v("题目可以理解为“存在A→B，那么以下哪些描述属实？”")]),t._v(" "),e("p",[t._v("可以将A看作是身份证号，B是姓名。身份证号唯一可以推导出姓名，但姓名不唯一，不一定可以推导出身份证号")]),t._v(" "),e("p",[t._v("A. 两个元组t1和t2在属性A上一致，在属性B上也一致。对。两个身份证号一样的元组，那么姓名肯定也是一致的。")]),t._v(" "),e("p",[t._v("B. 两个元组t1和t2在属性A上不一致，它们可能在属性B上一致。对，身份证号不一样，姓名可以一样。")]),t._v(" "),e("p",[t._v("C. 两个元组t1和t2在属性A上一致，但在属性B上不一致。错。身份证号一样，姓名肯定一样。")]),t._v(" "),e("p",[t._v("D. 两个元组t1和t2在属性A上不一致，它们可能在属性B上不一致。对。身份证号不一样，那么姓名可能也不一样。")]),t._v(" "),e("p",[t._v("所以选ABD。")])]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("7.Show each of the following FD, choose the right.（AC）")]),t._v(" "),e("p",[t._v("A.\tif A→B and B→C then A→C.")]),t._v(" "),e("p",[t._v("B.\tif AB→C and A→C then B→C.")]),t._v(" "),e("p",[t._v("C.\tif AB→C and A→BC then A→B.")]),t._v(" "),e("p",[t._v("D.\tif AB→CD and A→D then B→C.")]),t._v(" "),e("details",{staticClass:"custom-block details"},[e("summary",[t._v("【解析】")]),t._v(" "),e("p",[t._v("题目意思是“以下选项中成立的有哪些？”")]),t._v(" "),e("p",[t._v("A是传递规则，C是分解原则，另外两个不成立")])]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("8.For the following relation schema and set of FD's: R(A,B,C,D,E) with FD's:AB→DE.C→E,D→C and E→A.")]),t._v(" "),e("p",[t._v("(1)What are all the keys of R?")]),t._v(" "),e("p",[t._v("AB,ABD,ABC,ABE,ABCD,ABDE,ABCDE")]),t._v(" "),e("details",{staticClass:"custom-block details"},[e("summary",[t._v("【解析】")]),t._v(" "),e("p",[t._v("AB→D→C→E→A,AB→B")]),t._v(" "),e("p",[t._v("AB可以推导出其他元素，所以只要含有AB就是R的键")])]),t._v(" "),e("p",[t._v("(2)What are all the superkeys for R?")]),t._v(" "),e("p",[t._v("AB,ABD,ABC,ABE,ABCD,ABDE,ABCDE")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("9.We have relation R(A,B,C,D,E), find the minimal bases for the FD's {B→DE,C→CE,C→A,E→A}")]),t._v(" "),e("p",[t._v("BCE")]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"参考注释"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考注释"}},[t._v("#")]),t._v(" 参考注释")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://baike.baidu.com/item/Armstrong%E5%85%AC%E7%90%86/1187858?fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[t._v("Armstrong公理"),e("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=a.exports}}]);